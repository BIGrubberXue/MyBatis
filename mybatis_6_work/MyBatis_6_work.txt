MyBatis包含一个功能强大的事务查询缓存功能，该功能非常易于配置和定制。


------------------------------------------------------------------------------------
一级缓存(本地缓存)
	与数据库同一次会话期间查询到的数据会放在本地缓存中，
	以后如果需要获得同样的数据，直接从缓存中拿，没必要再去查询数据库
	一级缓存失效的情况(没有使用到当前一级缓存，还需要向数据库发送查询)
	1.sqlsession不同
	2.SQL session相同，查询条件不同
	3.SQL session相同，两次查询之间执行了增删改操作(这次增删改可能影响数据)
	4.SQL session相同，手动清除一级缓存

------------------------------------------------------------------------------------

二级缓存(全局缓存)
	基于namespace级别的缓存:一个namespace对应一个二级缓存
	工作机制:1.一个会话查询一条数据，这个数据就会被放在当前的一级缓存，
	              2.如果会话关闭，一级缓存中的数据会被保存到二级缓存中:新的会话查询信息，就可以参考二级缓存中的内容
	              3.不同的namespace查出的数据会放在自己对应的缓存中(map)
		效果: 数据会从二级缓存中获取
		         查出的数据会被默认先放在一级缓存中
		         只有会话提交或者关闭以后，一级缓存中的数据才会被转移到二级缓存中
	使用: 1.开启二级缓存配置.<setting name="cacheEnabled" value="true">
	        2. 去mapper.xml 中配置二级缓存
		<cache evication=""></cache>
		<!--
		eviction:缓存策略
		-LRU-最近最少使用。移除最长时间不被使用
		-FIFO-先进先出。按对象进入缓存的顺序来移除他们
		-SOFT-软引用，移除基于垃圾回收状态和软引用状态的对象
		-WEAK-弱引用，更积极地移除基于垃圾收集器状态和弱引用规则得对象。
		-默认是LRU
		flushInterval: 缓存刷新间隔
		    缓存多长时间清空一次，默认不清空，设置一个毫秒值
		readOnly: 是否只读  默认 flase
		-  true:只读mybatis认为i所有从缓存中获得数据的操作都是只读，不会修改数据
		-  false: 非只读：mybatis觉得获得的数据可能会被修改。mybatis 会利用序列化&反序列化的技术克隆一份新的数据给你。安全，速度慢
		- size:缓存从放多少元素
			typr="",指定自定义缓存的全类名
	       3.我们的POJO需要实现序列化接口
		->	

------------------------------------------------------------------------------------
和缓存有关的设置
1.cacheEnabled="true|false" 关闭缓存二级缓存，一级缓存一直可用
2. 每个select标签都有useCache="true"  false：不使用二级缓存	，一级缓存一直可用
3.flushCache="true"(每个增删改都有 默认为true  | select 默认false)  一、二级缓存清空
4.sqlsession.clearCache() 只清除当前session的一级缓存
5.localCacheScope : 本地缓存作用域：(一级缓存    session):当前会话的所有数据保存在会话缓存中    statement 可以禁用一级缓存。